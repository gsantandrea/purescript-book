{"id":"../output/Type.Data.Row/index.js","dependencies":[{"name":"/home/giuliano/prove/prove_purescript/purescript-book/exercises/chapter8/output/Type.Data.Row/index.js.map","includedInParent":true,"mtime":1585476658078},{"name":"/home/giuliano/prove/prove_purescript/purescript-book/exercises/chapter8/.spago/prelude/v4.1.1/src/Type/Data/Row.purs","includedInParent":true,"mtime":1585416327954},{"name":"/home/giuliano/prove/prove_purescript/purescript-book/exercises/chapter8/package.json","includedInParent":true,"mtime":1585424477455}],"generated":{"js":"// Generated by purs version 0.13.6\n\"use strict\";\n\nvar RProxy = function () {\n  function RProxy() {}\n\n  ;\n  RProxy.value = new RProxy();\n  return RProxy;\n}();\n\nmodule.exports = {\n  RProxy: RProxy\n};"},"sourceMaps":{"js":{"mappings":[{"source":"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs","name":null,"original":{"line":19,"column":0},"generated":{"line":4,"column":0}},{"source":"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs","name":null,"original":{"line":19,"column":0},"generated":{"line":4,"column":4}},{"source":"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs","name":null,"original":{"line":19,"column":0},"generated":{"line":4,"column":10}},{"source":"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs","name":null,"original":{"line":19,"column":0},"generated":{"line":4,"column":13}},{"source":"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs","name":null,"original":{"line":19,"column":0},"generated":{"line":4,"column":25}},{"source":"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs","name":null,"original":{"line":19,"column":0},"generated":{"line":10,"column":1}},{"source":"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs","name":null,"original":{"line":19,"column":0},"generated":{"line":10,"column":3}}],"sources":{"../../.spago/prelude/v4.1.1/src/Type/Data/Row.purs":"module Type.Data.Row where\n\n-- | A proxy data type whose type parameter is a type of kind `# Type` (a row\n-- | of types).\n-- |\n-- | Commonly used for specialising a function with a quantified type.\n-- | For example, suppose we have an identity function for records of type:\n-- | ```purescript\n-- | recordIdentity :: forall row . RProxy row -> Record row -> Record row\n-- | recordIdentity _ rec = rec\n-- | ```\n-- | Then applying this function to an `RProxy` with a specialised type\n-- | allows us to specify a concrete type for `row`:\n-- | ```purescript\n-- | :t recordIdentity (RProxy :: RProxy ( x :: Int, y :: Int ))\n-- | { x :: Int, y :: Int } -> { x :: Int, y :: Int }\n-- | ```\n-- | Here `row` has been specialised to `( x :: Int, y :: Int )`.\ndata RProxy (row :: # Type)\n  = RProxy\n"},"lineCount":null}},"error":null,"hash":"030dce7d893186308ace5646ee17b43e","cacheData":{"env":{}}}